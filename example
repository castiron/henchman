#!/bin/bash
###################
##~~~~~~~~~~~~~~~##
##~~~~Example~~~~##
##~~~~~~~~~~~~~~~##
###################

# See Option 2 in "Call upon the Henchman"
henchman_version="v1.0"
henchman_location="/tmp"

# Your scripting should happen inside the main function: main(){ ...something scripty... }
main() {
    # 1) Variables
    echo -e "1) Variables\n"
    local var_scope="I'm scoped to the main function"
    local some_var="I can be assigned inline"
    local another_var
    another_var="or first declared then assigned later"
    echo "var_scope: ${var_scope}"
    echo "some_var: ${some_var}"
    echo "another_var: ${another_var}"
    echo -e "\n\n"


    # 2) Handling Henchman return value
    echo -e "2) Handling Henchman return value\n"
    ## Inline assignment
    local working_dir
    echo "hm_do hm_get_working_directory && working_dir=\${hm_return}"
    hm_do hm_get_working_directory && working_dir=${hm_return}
    echo "working_dir: ${working_dir}"

    ## Use return value without assignment
    ## Note: ${hm_return} will be overwritten on subsequent Henchman function call
    echo "hm_do hm_file_exist? \"\${working_dir}/README.md\""
    hm_do hm_file_exist? "${working_dir}/README.md"
    if [ ${hm_return} ]
    then
        echo "${working_dir}/README.md really exists!"
    else
        echo "${working_dir}/README.md does not exist."
    fi
    echo -e "\n\n"


    # 3) Main parameters
    echo -e "3) Main parameters\n"
    ## Example script called with params: example param1 param2
    ## Henchman stores these in global vars to allow for the bootstrap process to work the way that it does.
    echo "I was passed ${main_params_count} params."
    echo "And here are the params: ${main_params}"
    echo -e "\n\n"


    # 4) Error handling
    echo -e "4) Error handling\n"
    ## Henchman provides some basic parameter validation and error handling
    ## When an error is thrown a basic call stack is displayed and the pid is killed to ensure all execution halts.

    # Call Henchman function with too many parameters
    echo "Example of function call with too many parameters:"
    echo "hm_do hm_file_exist? \"this\" \"that\" \"something\""
    hm_do hm_file_exist? "this" "that" "something"
}

# Call upon the Henchman

# Option 1 - Local development / static deployment
# source "henchman"

# Option 2 - Dynamic loading
# Note: relies on version and location to store henchman to be passed as params
henchman_load() {
    local hm_url="https://raw.githubusercontent.com/castiron/henchman/${1}/henchman"
    local hm_local_file="${2}/henchman-${1}"
    echo -e "Attempting to fetch Henchman ${1}\n"
    if [ -e ${hm_local_file} ]
    then
        echo -e "Henchman ${1} is ready for action."
    else
        if hash curl 2>/dev/null; then
            curl ${hm_url} -o ${hm_local_file}
        elif hash wget 2>/dev/null; then
            wget ${hm_url} -O ${hm_local_file}
        else
            echo "Error! curl or wget required to fetch Henchman."
        fi
    fi
    source ${hm_local_file}
}
# Minified: henchman_load() { local hm_url="https://raw.githubusercontent.com/castiron/henchman/${1}/henchman";local hm_local_file="${2}/henchman-${1}";echo -e "Attempting to fetch Henchman ${1}\n";if [ -e ${hm_local_file} ];then echo -e "Henchman ${1} is ready for action.";else if hash curl 2>/dev/null;then curl ${hm_url} -o ${hm_local_file};elif hash wget 2>/dev/null;then wget ${hm_url} -O ${hm_local_file};else echo "Error! curl or wget required to fetch Henchman.";fi;fi;source ${hm_local_file}; }
henchman_load ${henchman_version} ${henchman_location}
